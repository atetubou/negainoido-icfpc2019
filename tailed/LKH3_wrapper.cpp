/*
 * Wrapper for LKH3
 * http://akira.ruc.dk/~keld/research/LKH-3/
 */

#include "tailed/LKH3_wrapper.h"

#include <algorithm>
#include <fstream>
#include <iostream>
#include <string>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <queue>
#include <random>

#include <experimental/filesystem>

#include "glog/logging.h"

using namespace std;


typedef vector<vector<int>> dist_matrix_t;

string tempfile_name() {
	char buffer[L_tmpnam + 1];
	char *p = tmpnam(buffer);
	string name(p);
	return name;
}

vector<int> SolveTSPByLKH3(const dist_matrix_t &d, const char *path_to_LKH3) {
	int n = (int)d.size();

	/* Write down distance matrix to a file */
	string file_tsp_name = tempfile_name();

	ofstream file_tsp(file_tsp_name.c_str());
	file_tsp << "NAME: swiss42" << endl;
	file_tsp << "TYPE: TSP"  << endl;
	file_tsp << "COMMENT: this is automatically generated by SolveTSPByLKH3"  << endl;
	file_tsp << "DIMENSION: " << n << endl;
	file_tsp << "EDGE_WEIGHT_TYPE: EXPLICIT"  << endl;
	file_tsp << "EDGE_WEIGHT_FORMAT: FULL_MATRIX "  << endl;
	file_tsp << "EDGE_WEIGHT_SECTION"  << endl;

	for(int i = 0; i < n; i++) {
	  LOG_IF(FATAL, (int)d[i].size() != n);
	  for(int j = 0; j < n; j++) {
	    if (j) file_tsp << " ";
	    file_tsp << d[i][j];
	  }
	  file_tsp << endl;
	}

	file_tsp << "EOF"  << endl;

	file_tsp.close();


	/* Write parameter file */
	string file_par_name = tempfile_name();
	string file_output_name = tempfile_name();
	ofstream file_par(file_par_name.c_str());
	file_par << "PROBLEM_FILE = " << file_tsp_name.c_str() << endl;
	file_par << "MOVE_TYPE = 5" << endl;
	file_par << "PATCHING_C = 3" << endl;
	file_par << "PATCHING_A = 2" << endl;
	// file_par << "RUNS = 1" << endl;
	file_par << "OUTPUT_TOUR_FILE = " << file_output_name << endl;
	file_par.close();


	string sh = path_to_LKH3;
	sh += " ";
	sh += file_par_name;
	sh += " >&2";
	int res = system(sh.c_str());

	if (res != 0) {
		cerr << "Error while running LKH3" << endl;
		exit(res);
	}


	/* Example output:
NAME : swiss42.3.tour
COMMENT : Length = 3
COMMENT : Found by LKH [Keld Helsgaun] Sat Jun 22 02:08:35 2019
TYPE : TOUR
DIMENSION : 3
TOUR_SECTION
1
2
3
-1
EOF
*/
	ifstream in(file_output_name.c_str());
	string buf;

	while(getline(in, buf)) {
		if (buf == "TOUR_SECTION") {
			break;
		}
	}
	vector<int> tour;
	int v;
	while(in >> v) {
		if (v == -1) break;
		tour.push_back(v - 1);
	}
	in.close();

	return tour;

}

std::vector<std::pair<int, int>>
SolveShrinkedTSP(const AI& ai, int n, const std::string& path_to_LKH3) {
  int sx = 0, sy = 0;
  std::vector<std::pair<int, int>> selected;
  const auto& board = ai.board;
  std::vector<std::vector<int>>
    selected_to_pos(board.size(),
		    std::vector<int>(board[0].size(), -1));

  for (size_t i = 0; i < board.size(); ++i) {
    for (size_t j = 0; j < board[i].size(); ++j) {
      if (board[i][j] == '#') continue;
      if (ai.get_pos() == std::make_pair(int(i), int(j))){
	sx = i;
	sy = j;
	continue;
      }
      selected.emplace_back(i, j);
    }
  }

  std::random_device seed_gen;
  std::mt19937 engine(seed_gen());
  std::shuffle(selected.begin(), selected.end(), engine);

  n = std::min<int>(selected.size(), n);
  selected.resize(n);
  selected.emplace_back(sx, sy);

  std::reverse(selected.begin(), selected.end());
  ++n;

  for (auto i = 0u; i < selected.size(); ++i) {
    const auto& s = selected[i];
    selected_to_pos[s.first][s.second] = i;
  }

  int dx[] = {0, 0, 1, -1};
  int dy[] = {1, -1, 0, 0};

  std::vector<std::vector<int>> matrix(n, std::vector<int>(n, 1e8));

  for (auto sidx = 0u; sidx < selected.size(); ++sidx) {
    const auto& start = selected[sidx];
    std::queue<std::pair<int, int>> q;
    q.push(start);
    std::vector<std::vector<int>> cost(board.size(),
				       std::vector<int>(board[0].size(), -1));
    cost[start.first][start.second] = 0;

    while (!q.empty()) {
      const auto cur = q.front();
      q.pop();
      for (int i = 0; i < 4; ++i) {
	int nx = cur.first + dx[i];
	int ny = cur.second + dy[i];
	if (nx < 0 || ny < 0 ||
	    nx >= static_cast<int>(board.size()) ||
	    ny >= static_cast<int>(board[nx].size()) ||
	    board[nx][ny] == '#' || cost[nx][ny] != -1) {
	  continue;
	}
	cost[nx][ny] = cost[cur.first][cur.second] + 1;
	q.push(std::make_pair(nx, ny));
      }
    }

    for (auto gidx = 0u; gidx < selected.size(); ++gidx) {
      const auto& g = selected[gidx];
      matrix[sidx][gidx] = cost[g.first][g.second];
    }
  }

  const auto& ans = SolveTSPByLKH3(matrix, path_to_LKH3.c_str());

  CHECK_EQ(ans.size(), selected.size());
  {
    int sum = 0;
    for (auto i = 0u; i + 1 < ans.size(); ++i) {
      int s = ans[i];
      int t = ans[i+1];
      sum += matrix[s][t];
    }
    LOG(INFO) << "sum " << sum;
  }

  std::vector<std::pair<int, int>> ret;
  // find 0 (start position)
  int start = 0;
  for (auto j = 0u; j < ans.size(); ++j) {
    if (ans[j] == 0) {
      start = j;
      break;
    }
  }

  for (auto i = 0u; i < ans.size(); ++i) {
    ret.push_back(selected[(start + i) % ans.size()]);
  }


  return ret;
}


/*
int main() {
	dist_matrix_t v(3, vector<int>(3, 1));
	for(int i=0; i<3; i++) v[i][i] = 0;
	SolveTSPByLKH3(v, "./LKH");
}
*/
