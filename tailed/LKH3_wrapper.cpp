/*
 * Wrapper for LKH3
 * http://akira.ruc.dk/~keld/research/LKH-3/
 */

#include "tailed/LKH3_wrapper.h"

#include <algorithm>
#include <fstream>
#include <iostream>
#include <string>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <queue>
#include <random>

#include <experimental/filesystem>

#include "glog/logging.h"
#include "gflags/gflags.h"

#include "base/graph.h"

DEFINE_string(LKH3path, "./tailed/LKH", "");

using namespace std;

typedef vector<vector<int>> dist_matrix_t;

string tempfile_name() {
	char buffer[L_tmpnam + 1];
	char *p = tmpnam(buffer);
	string name(p);
	return name;
}

vector<int> SolveTSPByLKH3(const dist_matrix_t &d, const char *path_to_LKH3) {
	int n = (int)d.size();

	/* Write down distance matrix to a file */
	string file_tsp_name = tempfile_name();

	ofstream file_tsp(file_tsp_name.c_str());
	file_tsp << "NAME: swiss42" << endl;
	file_tsp << "TYPE: TSP"  << endl;
	file_tsp << "COMMENT: this is automatically generated by SolveTSPByLKH3"  << endl;
	file_tsp << "DIMENSION: " << n << endl;
	file_tsp << "EDGE_WEIGHT_TYPE: EXPLICIT"  << endl;
	file_tsp << "EDGE_WEIGHT_FORMAT: FULL_MATRIX "  << endl;
	file_tsp << "EDGE_WEIGHT_SECTION"  << endl;

	for(int i = 0; i < n; i++) {
	  LOG_IF(FATAL, (int)d[i].size() != n);
	  for(int j = 0; j < n; j++) {
	    if (j) file_tsp << " ";
	    file_tsp << d[i][j];
	  }
	  file_tsp << endl;
	}

	file_tsp << "EOF"  << endl;

	file_tsp.close();


	/* Write parameter file */
	string file_par_name = tempfile_name();
	string file_output_name = tempfile_name();
	ofstream file_par(file_par_name.c_str());
	file_par << "PROBLEM_FILE = " << file_tsp_name.c_str() << endl;
	file_par << "MOVE_TYPE = 5" << endl;
	file_par << "PATCHING_C = 3" << endl;
	file_par << "PATCHING_A = 2" << endl;
	// file_par << "RUNS = 1" << endl;
	file_par << "OUTPUT_TOUR_FILE = " << file_output_name << endl;
	file_par.close();


	string sh = path_to_LKH3;
	sh += " ";
	sh += file_par_name;
	sh += " >&2";
	int res = system(sh.c_str());

	if (res != 0) {
		cerr << "Error while running LKH3" << endl;
		exit(res);
	}


	/* Example output:
NAME : swiss42.3.tour
COMMENT : Length = 3
COMMENT : Found by LKH [Keld Helsgaun] Sat Jun 22 02:08:35 2019
TYPE : TOUR
DIMENSION : 3
TOUR_SECTION
1
2
3
-1
EOF
*/
	ifstream in(file_output_name.c_str());
	string buf;

	while(getline(in, buf)) {
		if (buf == "TOUR_SECTION") {
			break;
		}
	}
	vector<int> tour;
	int v;
	while(in >> v) {
		if (v == -1) break;
		tour.push_back(v - 1);
	}
	in.close();

	return tour;

}

std::vector<int> SolveByOurselfs(const std::vector<std::vector<int>>& matrix) {
  std::vector<int> bestans;
  for (auto i = 0u; i < matrix.size(); ++i) {
    bestans.push_back(i);
  }

  auto cost = [&](const std::vector<int>& ans) -> int {
		int sum = 0;
		for (auto i = 0u; i + 1 < ans.size(); ++i) {
		  sum += matrix[ans[i]][ans[i+1]];
		}
		return sum;
	      };

  int cur_cost = cost(bestans);

  std::mt19937 engine;

  for (int i = 0; i < 100; ++i) {
    auto tans = bestans;
    std::shuffle(tans.begin() + 1, tans.end(), engine);

    int tcost = cost(tans);
    if (tcost < cur_cost) {
      bestans = tans;
      cur_cost = tcost;
    }
  }

  return bestans;
}

std::vector<std::pair<int, int>>
SolveShrinkedTSP(const AI& ai, int n, const std::string& path_to_LKH3) {
  int sx = 0, sy = 0;
  std::vector<std::pair<int, int>> selected;
  const auto& board = ai.board;
  std::vector<std::vector<int>>
    selected_to_pos(board.size(),
		    std::vector<int>(board[0].size(), -1));

  for (size_t i = 0; i < board.size(); ++i) {
    for (size_t j = 0; j < board[i].size(); ++j) {
      if (board[i][j] == '#') continue;
      if (ai.get_pos() == std::make_pair(int(i), int(j))){
	sx = i;
	sy = j;
	continue;
      }
      selected.emplace_back(i, j);
    }
  }

  std::mt19937 engine;
  std::shuffle(selected.begin(), selected.end(), engine);

  n = std::min<int>(selected.size(), n);
  selected.resize(n);
  selected.emplace_back(sx, sy);

  std::reverse(selected.begin(), selected.end());
  ++n;

  for (auto i = 0u; i < selected.size(); ++i) {
    const auto& s = selected[i];
    selected_to_pos[s.first][s.second] = i;
  }

  int dx[] = {0, 0, 1, -1};
  int dy[] = {1, -1, 0, 0};

  std::vector<std::vector<int>> matrix(n, std::vector<int>(n, 1e8));

  for (auto sidx = 0u; sidx < selected.size(); ++sidx) {
    const auto& start = selected[sidx];
    std::queue<std::pair<int, int>> q;
    q.push(start);
    std::vector<std::vector<int>> cost(board.size(),
				       std::vector<int>(board[0].size(), -1));
    cost[start.first][start.second] = 0;

    while (!q.empty()) {
      const auto cur = q.front();
      q.pop();
      for (int i = 0; i < 4; ++i) {
	int nx = cur.first + dx[i];
	int ny = cur.second + dy[i];
	if (nx < 0 || ny < 0 ||
	    nx >= static_cast<int>(board.size()) ||
	    ny >= static_cast<int>(board[nx].size()) ||
	    board[nx][ny] == '#' || cost[nx][ny] != -1) {
	  continue;
	}
	cost[nx][ny] = cost[cur.first][cur.second] + 1;
	q.push(std::make_pair(nx, ny));
      }
    }

    for (auto gidx = 0u; gidx < selected.size(); ++gidx) {
      const auto& g = selected[gidx];
      matrix[sidx][gidx] = cost[g.first][g.second];
    }
    matrix[0][sidx] = 0;
  }

  const auto& ans = SolveTSPByLKH3(matrix, path_to_LKH3.c_str());
  // const auto& ans = SolveByOurselfs(matrix);
  {
    auto board = ai.board;
    for (auto i = 0u; i < ans.size(); ++i) {
      const auto& s = selected[ans[i]];
      board[s.first][s.second] = i + 128;
    }

    for (const auto& row : board) {
      for (const auto& g : row) {
	if (g >= 0) {
	  std::cerr << g << g;
	} else {
	  char buf[8];
	  sprintf(buf, "%2d", static_cast<unsigned char>(g)-128);
	  std::cerr << buf;
	}
      }
      std::cerr << std::endl;
    }
  }

  CHECK_EQ(ans.size(), selected.size());
  {
    int sum = 0;
    for (auto i = 0u; i + 1 < ans.size(); ++i) {
      int s = ans[i];
      int t = ans[i+1];
      sum += matrix[s][t];
    }
    LOG(INFO) << "sum " << sum;
  }

  std::vector<std::pair<int, int>> ret;

  for (const auto &a : ans) {
    ret.push_back(selected[a]);
  }

  return ret;
}

std::vector<std::vector<pos>> get_groups(const AI& ai,
					 const std::vector<pos>& tsp_tours,
					 const std::vector<pos>& want_visit) {
  int w = ai.board.size();
  int h = ai.board[0].size();

  std::vector<std::vector<bool>> visited(w, std::vector<bool>(h));
  std::vector<std::vector<pos>> groups(tsp_tours.size());

  std::queue<std::pair<int, pos>> q;
  for (auto i = 0u; i < tsp_tours.size(); ++i) {
    q.push(std::make_pair(i, tsp_tours[i]));
  }

  int dx[] = {0, 0, 1, -1};
  int dy[] = {1, -1, 0, 0};

  while (!q.empty()) {
    auto cur = q.front();
    q.pop();
    auto curpos = cur.second;
    if (visited[curpos.first][curpos.second]) {
      continue;
    }
    visited[curpos.first][curpos.second] = true;
    groups[cur.first].push_back(curpos);

    for (int i = 0; i < 4; ++i) {
      int nx = curpos.first + dx[i];
      int ny = curpos.second + dy[i];
      if (nx < 0 || ny < 0 || nx >= w || ny >= h ||
	  ai.board[nx][ny] == '#' || visited[nx][ny]) {
	continue;
      }
      q.push({cur.first, {nx, ny}});
    }
  }

  return groups;
}

std::vector<std::pair<int, int>> tikutaOrder(const AI& ai, int n,
					     const std::vector<std::pair<int, int>>& want_visit) {
  {
    auto board = ai.board;
    auto p = ai.get_pos();
    board[p.first][p.second] = 'W';
    for (auto b : board) {
      LOG(INFO) << b;
    }
  }

  auto tsp_tours = SolveShrinkedTSP(ai, n, FLAGS_LKH3path);

  auto groups = get_groups(ai, tsp_tours, want_visit);

  {
    auto board = ai.board;
    auto p = ai.get_pos();
    board[p.first][p.second] = 'W';
    for (auto i = 0u; i < groups.size(); ++i) {
      for (const auto& g : groups[i]) {
	auto& b = board[g.first][g.second];
	if (b == '.') b = 128 + i;
      }
    }

    for (const auto& row : board) {
      for (const auto& g : row) {
	if (g >= 0) {
	  std::cerr << g << g;
	} else {
	  char buf[8];
	  sprintf(buf, "%2d", static_cast<unsigned char>(g)-128);
	  std::cerr << buf;
	}
      }
      std::cerr << std::endl;
    }    
  }

  GridGraph gridg(ai.board);

  std::vector<pos> order;

  {
    std::vector<std::vector<bool>> visited(ai.board.size(),
					   std::vector<bool>(ai.board[0].size()));
    pos cur = groups[0][0];

    for (auto group : groups) {
      for(;;) {
	order.push_back(cur);
	visited[cur.first][cur.second] = true;
	bool end = true;

	int nearest = 1e9;
	pos ne;

	for (const auto& p : group) {
	  if (visited[p.first][p.second]) {
	    continue;
	  }
	  end = false;
	  int nc = gridg.shortest_path(cur.first, cur.second,
				       p.first, p.second);
	  if (nc < nearest) {
	    nearest = nc;
	    ne = p;
	  }
	}

	if (end) break;
	cur = ne;
      }
    }
  }

}

/*
int main() {
	dist_matrix_t v(3, vector<int>(3, 1));
	for(int i=0; i<3; i++) v[i][i] = 0;
	SolveTSPByLKH3(v, "./LKH");
}
*/
